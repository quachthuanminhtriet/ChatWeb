import { Component, OnInit, ViewChild, ElementRef, AfterViewChecked } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { FormsModule } from '@angular/forms';
import { ChatService } from '../../../services/chat.service';
import { MatInputModule } from '@angular/material/input';
import { DatePipe } from '@angular/common'; // ƒê·ªãnh d·∫°ng l·∫°i time

@Component({
  selector: 'app-messages',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatIconModule,
    MatInputModule,
  ],
  providers: [DatePipe],
  templateUrl: './messages.component.html',
  styleUrls: ['./messages.component.css']
})
export class MessagesComponent implements OnInit, AfterViewChecked {
  @ViewChild('chatContent', { static: false }) chatContent: ElementRef | undefined;

  selectedUser: any;  // Ng∆∞·ªùi d√πng ƒë∆∞·ª£c ch·ªçn
  selectedChat: any;  // D·ªØ li·ªáu chat cho ng∆∞·ªùi d√πng ƒë√£ ch·ªçn
  newMessage: string = '';  // Tin nh·∫Øn m·ªõi ƒë·ªÉ g·ª≠i
  isTyping: boolean = false;  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒëang nh·∫≠p tin nh·∫Øn hay kh√¥ng
  selectedFile: File | null = null;  // L∆∞u tr·ªØ file ng∆∞·ªùi d√πng ch·ªçn
  sendingMessage: boolean = false;  // Ki·ªÉm tra tr·∫°ng th√°i g·ª≠i tin nh·∫Øn

  constructor(private chatService: ChatService, private datePipe: DatePipe) { }

  ngOnInit(): void {
    this.chatService.selectedUser$.subscribe(user => {
      if (user) {
        this.selectedUser = user;
        this.selectedChat = user;

        console.log('Ng∆∞·ªùi d√πng ƒë∆∞·ª£c ch·ªçn:', user);

        this.chatService.getMessages(user._id).subscribe(response => {

          if (Array.isArray(response.messages)) {
            this.updateMessages(response.messages);
          } else if (Array.isArray(response)) {
            this.updateMessages(response);
          } else {
            console.warn("D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá:", response);
          }
        });
      }
    });

    this.chatService.messages$.subscribe((messages: any[]) => {
      console.log('üì® Nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn m·ªõi:', messages);
      this.updateMessages(messages);
    });
  }


  ngAfterViewChecked(): void {
    this.scrollToBottom();
  }

  scrollToBottom(): void {
    if (this.chatContent) {
      this.chatContent.nativeElement.scrollTop = this.chatContent.nativeElement.scrollHeight;
    }
  }

  formatTime(timestamp: string): string {
    return this.datePipe.transform(timestamp, 'HH:mm') || '';  // Ch·ªâ l·∫•y gi·ªù v√† ph√∫t
  }

  loadChat(user: any): void {
    if (user && user._id) {
      this.chatService.getMessages(user._id).subscribe((res: any) => {

        const messages = res.messages || [];

        if (Array.isArray(messages)) {
          this.selectedChat = {
            avatar: user.avatar || 'https://randomuser.me/api/portraits/men/34.jpg',
            fullName: user.fullName || user.name || 'Nguy·ªÖn VƒÉn A',
            messages: messages.map((msg: any) => ({
              text: msg.content,
              isSelf: msg.senderId === localStorage.getItem('userId'),
              createdAt: msg.createdAt,
              fileData: msg.fileData,
              file: msg.fileUrl,
              fileType: msg.type,
            }))
          };
        }
      });
    } else {
      console.log('‚ùå Kh√¥ng c√≥ user._id, kh√¥ng th·ªÉ load chat!');
    }
  }

  sendMessage() {
    console.log('G·ª≠i tin nh·∫Øn:', this.newMessage);

    if (this.newMessage.trim() && this.selectedUser && this.selectedUser._id && !this.sendingMessage) {
      this.sendingMessage = true;

      // L·∫•y currentUserId t·ª´ localStorage
      const currentUserId = localStorage.getItem('userId');
      if (!currentUserId) {
        console.error('User is not logged in');
        return;
      }

      // X√¢y d·ª±ng data cho tin nh·∫Øn
      const data: any = {
        receiverId: this.selectedUser._id,
        content: this.newMessage.trim(),
      };

      // N·∫øu c√≥ file, th√™m file v√†o data
      if (this.selectedFile) {
        data.file = this.selectedFile;
      }

      // T·∫°o m·ªôt tin nh·∫Øn t·∫°m th·ªùi
      const tempMessage = {
        text: this.newMessage.trim(),
        isSelf: true,
        createdAt: new Date().toISOString(),
        file: this.selectedFile ? URL.createObjectURL(this.selectedFile) : null, // D√πng URL.createObjectURL cho file t·∫°m
        fileName: this.selectedFile ? this.selectedFile.name : null, // Th√™m fileName n·∫øu c√≥ file
        fileType: this.selectedFile ? this.selectedFile.type : null, // Lo·∫°i file n·∫øu c√≥
        tempId: Date.now(), // ID t·∫°m ƒë·ªÉ nh·∫≠n di·ªán tin nh·∫Øn
      };

      // Th√™m tin nh·∫Øn t·∫°m v√†o chat
      this.selectedChat.messages.push(tempMessage);
      this.newMessage = ''; // X√≥a n·ªôi dung tin nh·∫Øn

      // G·ª≠i tin nh·∫Øn qua API
      this.chatService.sendMessage(data).subscribe({
        next: (response: any) => {
          console.log('Ph·∫£n h·ªìi t·ª´ server:', response);
          this.sendingMessage = false;

          // C·∫≠p nh·∫≠t tin nh·∫Øn t·∫°m v·ªõi th√¥ng tin t·ª´ server
          if (response && response.message) {
            const index = this.selectedChat.messages.findIndex(
              (msg: any) => msg.tempId === tempMessage.tempId
            );

            if (index !== -1) {
              this.selectedChat.messages[index] = {
                text: response.message.content,
                isSelf: true,
                createdAt: response.message.createdAt || new Date().toISOString(),
                file: response.message.fileUrl,
                fileType: response.message.type,
                id: response.message.id, // S·ª≠ d·ª•ng id tr·∫£ v·ªÅ t·ª´ server
                fileName: (response.message.fileData && response.message.fileData.fileName) || this.selectedFile?.name || 'unknown',
              };
            }

            // G·ª≠i tin nh·∫Øn qua WebSocket cho ng∆∞·ªùi nh·∫≠n
            this.chatService.sendMessageSocket(this.selectedUser._id, {
              senderId: localStorage.getItem('userId'),
              receiverId: this.selectedUser._id,
              content: response.message.content,
              createdAt: response.message.createdAt || new Date().toISOString(),
            });
          }
        },
        error: (err) => {
          console.error('L·ªói khi g·ª≠i tin nh·∫Øn:', err);
          this.sendingMessage = false;

          // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói t√πy theo m√£ l·ªói
          if (err.status === 400) {
            alert('L·ªói g·ª≠i tin nh·∫Øn: D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.');
          } else if (err.status === 500) {
            alert('L·ªói server: Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn.');
          } else {
            alert('ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.');
          }

          // N·∫øu g·ª≠i tin nh·∫Øn kh√¥ng th√†nh c√¥ng, x√≥a tin nh·∫Øn t·∫°m
          const index = this.selectedChat.messages.findIndex(
            (msg: any) => msg.tempId === tempMessage.tempId
          );
          if (index !== -1) {
            this.selectedChat.messages.splice(index, 1);
          }
        }
      });
    } else {
      console.error('Ch∆∞a ch·ªçn ng∆∞·ªùi nh·∫≠n ho·∫∑c tin nh·∫Øn tr·ªëng');
      alert('Vui l√≤ng nh·∫≠p tin nh·∫Øn!');
    }
  }


  updateMessages(messages: any[]): void {
    const currentUserId = localStorage.getItem('userId');
    console.log('Current User ID:', currentUserId);

    if (!this.selectedChat || !Array.isArray(messages) || !currentUserId) return;

    // ƒê·∫£m b·∫£o messages l√† m·∫£ng
    if (!Array.isArray(this.selectedChat.messages)) {
      this.selectedChat.messages = [];
    }

    // L·∫∑p qua t·∫•t c·∫£ c√°c tin nh·∫Øn m·ªõi
    messages.forEach((msg: any) => {
      const isMessageExist = this.selectedChat.messages.some(
        (existingMsg: any) =>
          existingMsg.text === msg.content &&
          existingMsg.createdAt === msg.createdAt
      );

      // N·∫øu tin nh·∫Øn ch∆∞a t·ªìn t·∫°i, th√™m v√†o danh s√°ch
      if (!isMessageExist) {
        const isSelf = String(msg.senderId) === String(currentUserId);
        console.log('Incoming socket message:', msg);

        this.selectedChat.messages.push({
          id: msg.id,  // S·ª≠ d·ª•ng message.id
          text: msg.content,
          isSelf: isSelf,
          createdAt: msg.createdAt,
          file: msg.fileUrl,
          fileType: msg.type,
          fileName: msg.fileName || msg.fileData?.fileName,
        });
      }
    });
  }



  markAsRead() {
    if (!this.selectedChat || !this.selectedChat.messages) return;

    this.selectedChat.messages.forEach((message: { isSelf: boolean; readTime?: string }) => {
      if (message.isSelf && !message.readTime) {
        message.readTime = this.formatTime(new Date().toISOString());
      }
    });
  }

  getCurrentTime(): string {
    const now = new Date();
    return this.datePipe.transform(now, 'HH:mm') || ''; // S·ª≠ d·ª•ng DatePipe ƒë·ªÉ ƒë·ªãnh d·∫°ng gi·ªù v√† ph√∫t
  }

  checkEmpty(): void {
    if (!this.newMessage.trim()) this.isTyping = false;
  }

  openFilePicker(type: string) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';

    if (type === 'image') {
      fileInput.accept = 'image/*';
    } else if (type === 'video') {
      fileInput.accept = 'video/*';
    } else {
      fileInput.accept = '*/*';
    }

    fileInput.addEventListener('change', (event: Event) => this.handleFileUpload(event));
    fileInput.click();
  }

  handleFileUpload(event: Event) {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length > 0) {
      const selectedFile = input.files[0];
      const MAX_FILE_SIZE_MB = 30;

      // Ki·ªÉm tra n·∫øu ch∆∞a ch·ªçn ng∆∞·ªùi nh·∫≠n
      if (!this.selectedUser || !this.selectedUser._id) {
        alert('Vui l√≤ng ch·ªçn ng∆∞·ªùi nh·∫≠n!');
        return;
      }

      // Ki·ªÉm tra k√≠ch th∆∞·ªõc file
      if (selectedFile.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
        alert(`File qu√° l·ªõn! Ch·ªâ cho ph√©p d∆∞·ªõi ${MAX_FILE_SIZE_MB}MB.`);
        return;
      }

      this.selectedFile = selectedFile;

      // T·∫°o FormData ƒë·ªÉ g·ª≠i file l√™n server
      const formData = new FormData();
      formData.append('file', selectedFile, selectedFile.name);
      formData.append('receiverId', String(this.selectedUser._id));

      // G·ª≠i file t·ªõi server
      this.chatService.sendFile(formData).subscribe({
        next: (response: any) => {
          console.log('üì¶ Response t·ª´ server:', response);
          console.log('üìÑ fileData:', response?.fileData);
          console.log('‚úâÔ∏è messageData:', response?.message);

          const fileData = response?.fileData;
          const messageData = response?.message;

          // Ki·ªÉm tra n·∫øu thi·∫øu d·ªØ li·ªáu t·ª´ server
          if (!fileData || !messageData?.id) {
            console.error('Thi·∫øu d·ªØ li·ªáu t·ª´ server!');
            alert('L·ªói: Thi·∫øu d·ªØ li·ªáu t·ª´ server!');
            return;
          }

          // Ki·ªÉm tra v√† g√°n th√¥ng tin tin nh·∫Øn
          const message = {
            id: messageData.id,
            isSelf: true,
            createdAt: messageData.createdAt || new Date().toISOString(),
            file: fileData.fileUrl || fileData.url || '', // Link t·∫£i file
            fileType: fileData.fileType.startsWith('image') ? 'image' :
              fileData.fileType.startsWith('video') ? 'video' : 'file', // X√°c ƒë·ªãnh lo·∫°i file
            fileData: {
              ...fileData,
              fileName: fileData.fileName || selectedFile.name,  // N·∫øu thi·∫øu t√™n file t·ª´ server, d√πng t√™n file g·ªëc
              fileType: fileData.fileType
            }
          };

          this.selectedChat.messages.push(message);

          this.chatService.sendMessageSocket(this.selectedUser._id, {
            senderId: localStorage.getItem('userId'),
            receiverId: this.selectedUser._id,
            content: '',
            createdAt: message.createdAt,
            fileUrl: message.file,
            fileType: message.fileType,
            fileName: message.fileData?.fileName,
            id: message.id,
          });


          this.selectedFile = null;
        },
        error: (err) => {
          console.error('L·ªói khi g·ª≠i file:', err);
          alert('C√≥ l·ªói khi g·ª≠i file!');
          this.selectedFile = null;
        }
      });
    }
  }

  downloadFile(message: any) {
    const fileId = message?.fileData?.id || message.id; // ∆Øu ti√™n ID t·ª´ fileData
    const fileName = message.fileName || 'file_download';

    if (!fileId) {
      alert('Kh√¥ng th·ªÉ t·∫£i file: Thi·∫øu ID');
      return;
    }

    this.chatService.downloadFile(fileId).subscribe({
      next: (fileBlob) => {
        const url = window.URL.createObjectURL(fileBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;  // T·∫£i file v·ªÅ v·ªõi t√™n file
        a.click();
        window.URL.revokeObjectURL(url);
      },
      error: (err) => {
        console.error('L·ªói khi t·∫£i file:', err);
        alert('C√≥ l·ªói khi t·∫£i file!');
      }
    });
  }

}
